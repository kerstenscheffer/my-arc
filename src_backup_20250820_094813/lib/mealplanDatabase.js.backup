// src/lib/mealplanDatabase.js — unified module with all required exports
import { supabase } from './supabase'

/** =========================
 *  MEALS CATALOG
 *  Table: meals(id, name, kcal, protein, carbs, fat, tags text[])
 *  ========================= */
export async function getMeals({ q = '', tags = [], limit = 50 } = {}) {
  let query = supabase
    .from('meals')
    .select('*')
    .order('created_at', { ascending: false })
    .limit(limit)

  if (q) query = query.ilike('name', `%${q}%`)
  if (tags?.length) query = query.contains('tags', tags)

  const { data, error } = await query
  if (error) throw error
  return data || []
}

export async function listMealsNearCalories(targetKcal, window = 100, limit = 30) {
  const { data, error } = await supabase
    .from('meals')
    .select('*')
    .order('created_at', { ascending: false })
    .limit(200)
  if (error) throw error

  const low = Math.max(0, (targetKcal || 0) - window)
  const high = (targetKcal || 0) + window
  return (data || []).filter(m => m.kcal >= low && m.kcal <= high).slice(0, limit)
}

/** =========================
 *  MEAL PLAN TEMPLATES
 *  Table: meal_plan_templates(id, created_at, created_by, title, description, targets jsonb, week_structure jsonb)
 *  ========================= */
export async function createMealPlanTemplate({ title, description = '', targets, week_structure }) {
  const payload = { title, description, targets, week_structure }
  const { data, error } = await supabase
    .from('meal_plan_templates')
    .insert([payload])
    .select('*')
    .single()
  if (error) throw error
  return data
}

export async function listMealPlanTemplates() {
  const { data, error } = await supabase
    .from('meal_plan_templates')
    .select('id, title, description, targets, week_structure, created_at, created_by')
  if (error) throw error
  return data || []
}

export async function getMealPlanTemplate(id) {
  const { data, error } = await supabase
    .from('meal_plan_templates')
    .select('*')
    .eq('id', id)
    .single()
  if (error) throw error
  return data
}

/** =========================
 *  CLIENT MEAL PLANS (snapshots)
 *  Table: client_meal_plans(id, created_at, template_id, start_date, title, targets jsonb, week_structure jsonb, client_id uuid)
 *  ========================= */
export async function getClientMealPlans(client_id) {
  const { data, error } = await supabase
    .from('client_meal_plans')
    .select('*')
    .eq('client_id', client_id)
    .order('created_at', { ascending: false })
  if (error) throw error
  return data || []
}

export async function getClientActiveMealPlan(client_id) {
  const plans = await getClientMealPlans(client_id)
  return plans?.[0] || null
}

// Assign template → snapshot for a client (coach action)
export async function assignTemplateToClient({ template_id, client_id, start_date }) {
  if (!template_id || !client_id) throw new Error('Missing template_id or client_id')

  // 1) Load the template
  const { data: tpl, error: tplErr } = await supabase
    .from('meal_plan_templates')
    .select('id, title, description, targets, week_structure')
    .eq('id', template_id)
    .single()
  if (tplErr) throw tplErr
  if (!tpl) throw new Error('Template not found')

  // 2) Insert snapshot into client_meal_plans
  const payload = {
    client_id,
    template_id: tpl.id,
    start_date: start_date || new Date().toISOString().slice(0, 10),
    title: tpl.title,
    targets: tpl.targets || {},
    week_structure: tpl.week_structure || []
  }

  const { data, error } = await supabase
    .from('client_meal_plans')
    .insert([payload])
    .select('*')
    .single()
  if (error) throw error
  return data
}

/** =========================
 *  SHARED HELPERS
 *  ========================= */
export async function fetchMealsByIds(ids = []) {
  const unique = [...new Set(ids)].filter(Boolean)
  if (!unique.length) return []
  const { data, error } = await supabase
    .from('meals')
    .select('*')
    .in('id', unique)
  if (error) throw error
  return data || []
}

/** =========================
 *  CLIENT OVERRIDES (optioneel; alleen gebruiken als je de SQL-tabellen hebt aangemaakt)
 *  Table: client_meal_plan_overrides(plan_id, client_id, day_index int, slot text, meal_id)
 *  ========================= */
export async function saveClientMealSwap({ plan_id, client_id, day_index, slot, meal_id }) {
  // Als de overrides-tabel niet bestaat of RLS blokkeert, gooit Supabase een error.
  const { data, error } = await supabase
    .from('client_meal_plan_overrides')
    .upsert(
      [{ plan_id, client_id, day_index, slot, meal_id }],
      { onConflict: 'plan_id,client_id,day_index,slot', ignoreDuplicates: false }
    )
    .select('*')
    .single()
  if (error) throw error
  return data
}

async function getOverrides(plan_id, client_id) {
  const { data, error } = await supabase
    .from('client_meal_plan_overrides')
    .select('day_index, slot, meal_id')
    .eq('plan_id', plan_id)
    .eq('client_id', client_id)
  if (error) throw error
  return data || []
}

export async function getClientPlanWithOverrides(client_id) {
  const plan = await getClientActiveMealPlan(client_id)
  if (!plan) return { plan: null, mergedWeekStructure: [] }

  // Basis = snapshot uit client_meal_plans
  const base = Array.isArray(plan.week_structure)
    ? JSON.parse(JSON.stringify(plan.week_structure))
    : []

  // Merge overrides als de tabel aanwezig is
  try {
    const overrides = await getOverrides(plan.id, client_id)
    for (const ov of overrides) {
      const d = base[ov.day_index]
      if (!d) continue
      if (!Array.isArray(d.meals)) d.meals = []
      const idx = d.meals.findIndex(m => m.slot === ov.slot)
      if (idx !== -1) d.meals[idx].meal_id = ov.meal_id ?? null
      else d.meals.push({ slot: ov.slot, meal_id: ov.meal_id ?? null })
    }
  } catch (e) {
    // Als overrides-tabel (nog) niet bestaat, negeren we dat stilletjes
    console.warn('Overrides not applied:', e?.message || e)
  }

  return { plan, mergedWeekStructure: base }
}

// Add these functions to src/lib/mealplanDatabase.js

/** =========================
 *  SMART PLAN GENERATOR
 *  Intelligente meal planning met variatie, macro-balancing en portie-scaling
 *  ========================= */

// Get pool of meals voor smart planner
export async function getPlannerMealsPool({ 
  allowedTags = [], 
  bannedTags = [], 
  kcalRange = { min: 0, max: 9999 },
  limit = 500 
} = {}) {
  let query = supabase
    .from('meals')
    .select('id, name, kcal, protein, carbs, fat, tags, category, default_portion')
    .gte('kcal', kcalRange.min)
    .lte('kcal', kcalRange.max)
    .limit(limit)

  if (allowedTags?.length) {
    query = query.contains('tags', allowedTags)
  }
  
  // Filter banned tags na ophalen (Supabase heeft geen NOT contains)
  const { data, error } = await query
  if (error) throw error
  
  let filtered = data || []
  if (bannedTags?.length) {
    filtered = filtered.filter(meal => 
      !meal.tags?.some(tag => bannedTags.includes(tag))
    )
  }
  
  return filtered
}

// Smart plan generator voor 4 weken
export async function generateSmartPlanForClient({
  client_id,
  plan_id,
  start_date,
  dailyKcalTarget = 2000,
  dailyMacroTargets = { protein: 150, carbs: 200, fat: 67 },
  mealsPerDay = 4,
  preferences = [],
  allergies = []
}) {
  try {
    // 1. Haal meals pool op
    const mealsPool = await getPlannerMealsPool({
      allowedTags: preferences,
      bannedTags: allergies,
      limit: 600
    })
    
    if (!mealsPool.length) {
      throw new Error('Geen meals gevonden met deze criteria')
    }

    // 2. Categoriseer meals
    const mealsByCategory = {
      breakfast: [],
      lunch: [],
      dinner: [],
      snack: []
    }
    
    mealsPool.forEach(meal => {
      // Detecteer category uit tags of naam als niet aanwezig
      let category = meal.category
      if (!category) {
        if (meal.tags?.includes('ontbijt') || meal.tags?.includes('breakfast') || 
            /overnight|oats|yoghurt|granola|muesli/i.test(meal.name)) {
          category = 'breakfast'
        } else if (meal.tags?.includes('lunch') || /salade|bowl|wrap|sandwich/i.test(meal.name)) {
          category = 'lunch'
        } else if (meal.tags?.includes('diner') || meal.tags?.includes('dinner') || 
                   /curry|pasta|rijst|stamppot/i.test(meal.name)) {
          category = 'dinner'
        } else {
          category = 'snack'
        }
      }
      
      if (mealsByCategory[category]) {
        mealsByCategory[category].push(meal)
      } else {
        mealsByCategory.snack.push(meal)
      }
    })

    // 3. Bereken target calories per meal slot
    const mealDistribution = {
      breakfast: 0.25,  // 25% van dagelijkse calorieën
      lunch: 0.30,      // 30%
      dinner: 0.35,     // 35%
      snack: 0.10       // 10% (kan meerdere snacks zijn)
    }
    
    // 4. Genereer 28 dagen
    const weekStructure = []
    const usedMealsTracker = new Map() // Track laatste gebruik per meal
    const MIN_DAYS_BETWEEN_REPEATS = 3
    
    for (let day = 0; day < 28; day++) {
      const dayMeals = []
      const dayDate = new Date(start_date)
      dayDate.setDate(dayDate.getDate() + day)
      
      // Plan meals voor deze dag
      const mealSlots = mealsPerDay <= 3 ? 
        ['breakfast', 'lunch', 'dinner'] :
        mealsPerDay === 4 ?
        ['breakfast', 'lunch', 'dinner', 'snack'] :
        ['breakfast', 'snack', 'lunch', 'snack', 'dinner']
      
      mealSlots.forEach((slotCategory, slotIndex) => {
        const targetKcal = dailyKcalTarget * (mealDistribution[slotCategory] || 0.10)
        
        // Selecteer beste meal voor dit slot
        const candidates = mealsByCategory[slotCategory] || mealsByCategory.snack
        
        // Score candidates op basis van:
        // 1. Calorie match
        // 2. Variatie (niet recent gebruikt)
        // 3. Macro fit
        const scoredCandidates = candidates.map(meal => {
          let score = 100
          
          // Calorie matching (belangrijkst)
          const calorieDiff = Math.abs(meal.kcal - targetKcal)
          score -= (calorieDiff / 10) // -1 punt per 10 kcal afwijking
          
          // Variatie bonus
          const lastUsed = usedMealsTracker.get(meal.id)
          if (lastUsed !== undefined) {
            const daysSinceUsed = day - lastUsed
            if (daysSinceUsed < MIN_DAYS_BETWEEN_REPEATS) {
              score -= (100 - daysSinceUsed * 20) // Zware penalty voor recent gebruik
            } else {
              score += Math.min(daysSinceUsed * 2, 50) // Bonus voor lang niet gebruikt
            }
          } else {
            score += 50 // Bonus voor nog nooit gebruikt
          }
          
          // Macro fit (indien binnen 20% van target)
          const proteinRatio = meal.protein / (dailyMacroTargets.protein / mealsPerDay)
          if (proteinRatio > 0.8 && proteinRatio < 1.2) {
            score += 10
          }
          
          return { meal, score }
        })
        
        // Sorteer op score en kies beste optie
        scoredCandidates.sort((a, b) => b.score - a.score)
        const selected = scoredCandidates[0]?.meal
        
        if (selected) {
          dayMeals.push({
            slot: `${slotCategory}${slotIndex > 0 ? slotIndex : ''}`,
            meal_id: selected.id,
            targetKcal: Math.round(targetKcal)
          })
          
          // Update tracker
          usedMealsTracker.set(selected.id, day)
        }
      })
      
      weekStructure.push({
        day: `Day ${day + 1}`,
        date: dayDate.toISOString().slice(0, 10),
        meals: dayMeals
      })
    }

    // 5. Sla op als overrides (als plan_id gegeven)
    if (plan_id) {
      // Clear oude overrides
      await supabase
        .from('client_meal_plan_overrides')
        .delete()
        .eq('plan_id', plan_id)
        .eq('client_id', client_id)
      
      // Insert nieuwe overrides
      const overrides = []
      weekStructure.forEach((day, dayIndex) => {
        day.meals.forEach(meal => {
          overrides.push({
            plan_id,
            client_id,
            day_index: dayIndex,
            slot: meal.slot,
            meal_id: meal.meal_id
          })
        })
      })
      
      if (overrides.length) {
        const { error } = await supabase
          .from('client_meal_plan_overrides')
          .insert(overrides)
        if (error) throw error
      }
    }
    
    // 6. Return de structure
    return { 
      weekStructure,
      diagnostics: {
        totalMealsPlanned: weekStructure.reduce((sum, day) => sum + day.meals.length, 0),
        uniqueMealsUsed: usedMealsTracker.size,
        averageVarietyScore: Math.round((usedMealsTracker.size / mealsPool.length) * 100),
        mealsPerDay
      }
    }
    
  } catch (error) {
    console.error('Smart plan generation failed:', error)
    throw error
  }
}

// Regenereer specifieke dag
export async function regenerateDay({
  client_id,
  plan_id,
  day_index,
  currentStructure,
  dailyKcalTarget = 2000,
  mealsPerDay = 4
}) {
  try {
    // Gebruik dezelfde logica als generateSmartPlan maar voor 1 dag
    const mealsPool = await getPlannerMealsPool({ limit: 200 })
    
    // Bepaal welke meals al in andere dagen gebruikt worden (voor variatie)
    const usedMealIds = new Set()
    currentStructure.forEach((day, idx) => {
      if (Math.abs(idx - day_index) <= 3) { // Check 3 dagen ervoor en erna
        day.meals?.forEach(m => {
          if (m.meal_id) usedMealIds.add(m.meal_id)
        })
      }
    })
    
    // Filter pool voor variatie
    const availableMeals = mealsPool.filter(m => !usedMealIds.has(m.id))
    
    // Genereer nieuwe dag meals (simplified)
    const dayMeals = []
    const slots = ['breakfast', 'lunch', 'dinner', 'snack']
    
    for (let i = 0; i < Math.min(mealsPerDay, slots.length); i++) {
      const targetKcal = dailyKcalTarget / mealsPerDay
      
      // Vind beste match
      const bestMatch = availableMeals.reduce((best, meal) => {
        const diff = Math.abs(meal.kcal - targetKcal)
        if (!best || diff < best.diff) {
          return { meal, diff }
        }
        return best
      }, null)
      
      if (bestMatch?.meal) {
        dayMeals.push({
          slot: slots[i],
          meal_id: bestMatch.meal.id,
          targetKcal: Math.round(targetKcal)
        })
        
        // Remove uit available pool
        const idx = availableMeals.indexOf(bestMatch.meal)
        if (idx > -1) availableMeals.splice(idx, 1)
      }
    }
    
    // Update overrides in database
    if (plan_id) {
      // Delete oude overrides voor deze dag
      await supabase
        .from('client_meal_plan_overrides')
        .delete()
        .eq('plan_id', plan_id)
        .eq('client_id', client_id)
        .eq('day_index', day_index)
      
      // Insert nieuwe
      const overrides = dayMeals.map(meal => ({
        plan_id,
        client_id,
        day_index,
        slot: meal.slot,
        meal_id: meal.meal_id
      }))
      
      if (overrides.length) {
        const { error } = await supabase
          .from('client_meal_plan_overrides')
          .insert(overrides)
        if (error) throw error
      }
    }
    
    return {
      day: {
        day: `Day ${day_index + 1}`,
        meals: dayMeals
      }
    }
    
  } catch (error) {
    console.error('Day regeneration failed:', error)
    throw error
  }
}

// Regenereer hele week
export async function regenerateWeek({
  client_id,
  plan_id,
  week_index,
  currentStructure,
  dailyKcalTarget = 2000,
  dailyMacroTargets = { protein: 150, carbs: 200, fat: 67 },
  mealsPerDay = 4
}) {
  try {
    const startDayIndex = week_index * 7
    const endDayIndex = startDayIndex + 7
    
    // Genereer 7 nieuwe dagen
    const newWeekDays = []
    
    for (let dayIndex = startDayIndex; dayIndex < endDayIndex; dayIndex++) {
      const result = await regenerateDay({
        client_id,
        plan_id,
        day_index: dayIndex,
        currentStructure,
        dailyKcalTarget,
        mealsPerDay
      })
      
      newWeekDays.push(result.day)
    }
    
    return { week: newWeekDays }
    
  } catch (error) {
    console.error('Week regeneration failed:', error)
    throw error
  }
}

// Coach: Get all clients with their meal plan status
export async function getClientsWithMealPlanStatus(coach_id) {
  try {
    // Haal alle clients van deze coach
    const { data: clients, error: clientError } = await supabase
      .from('clients')
      .select('id, first_name, last_name, email, status, goals')
      .eq('trainer_id', coach_id)
      .eq('status', 'active')
      .order('created_at', { ascending: false })
    
    if (clientError) throw clientError
    
    // Voor elke client, check of ze een meal plan hebben
    const clientsWithStatus = await Promise.all(
      clients.map(async (client) => {
        const plans = await getClientMealPlans(client.id)
        return {
          ...client,
          hasMealPlan: plans.length > 0,
          latestPlanDate: plans[0]?.created_at || null
        }
      })
    )
    
    return clientsWithStatus
    
  } catch (error) {
    console.error('Error getting clients with meal plan status:', error)
    throw error
  }
}

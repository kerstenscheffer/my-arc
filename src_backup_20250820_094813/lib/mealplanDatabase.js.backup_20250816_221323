// src/lib/mealplanDatabase.js â€” unified module with all required exports + Preference Scoring
import { supabase } from './supabase'

/** =========================
 *  MEALS CATALOG
 *  Table: meals(id, name, kcal, protein, carbs, fat, tags text[])
 *  ========================= */
export async function getMeals({ q = '', tags = [], limit = 50 } = {}) {
  let query = supabase
    .from('meals')
    .select('*')
    .order('created_at', { ascending: false })
    .limit(limit)

  if (q) query = query.ilike('name', `%${q}%`)
  if (tags?.length) query = query.contains('tags', tags)

  const { data, error } = await query
  if (error) throw error
  return data || []
}

export async function listMealsNearCalories(targetKcal, window = 100, limit = 30) {
  const { data, error } = await supabase
    .from('meals')
    .select('*')
    .order('created_at', { ascending: false })
    .limit(200)
  if (error) throw error

  const low = Math.max(0, (targetKcal || 0) - window)
  const high = (targetKcal || 0) + window
  return (data || []).filter(m => m.kcal >= low && m.kcal <= high).slice(0, limit)
}

export async function createMeal(payload) {
  const { data, error } = await supabase
    .from('meals')
    .insert([payload])
    .select('*')
    .single()
  
  if (error) throw error
  return data
}

/** =========================
 *  MEAL PLAN TEMPLATES
 *  Table: meal_plan_templates(id, created_at, created_by, title, description, targets jsonb, week_structure jsonb)
 *  ========================= */
export async function createMealPlanTemplate({ title, description = '', targets, week_structure }) {
  const payload = { title, description, targets, week_structure }
  const { data, error } = await supabase
    .from('meal_plan_templates')
    .insert([payload])
    .select('*')
    .single()
  if (error) throw error
  return data
}

export async function listMealPlanTemplates() {
  const { data, error } = await supabase
    .from('meal_plan_templates')
    .select('id, title, description, targets, week_structure, created_at, created_by')
  if (error) throw error
  return data || []
}

export async function getMealPlanTemplate(id) {
  const { data, error } = await supabase
    .from('meal_plan_templates')
    .select('*')
    .eq('id', id)
    .single()
  if (error) throw error
  return data
}

/** =========================
 *  CLIENT MEAL PLANS (snapshots)
 *  Table: client_meal_plans(id, created_at, template_id, start_date, title, targets jsonb, week_structure jsonb, client_id uuid)
 *  ========================= */
export async function getClientMealPlans(client_id) {
  const { data, error } = await supabase
    .from('client_meal_plans')
    .select('*')
    .eq('client_id', client_id)
    .order('created_at', { ascending: false })
  if (error) throw error
  return data || []
}

export async function getClientActiveMealPlan(client_id) {
  const plans = await getClientMealPlans(client_id)
  return plans?.[0] || null
}

// Assign template â†’ snapshot for a client (coach action)
export async function assignTemplateToClient({ template_id, client_id, start_date }) {
  if (!template_id || !client_id) throw new Error('Missing template_id or client_id')

  // 1) Load the template
  const { data: tpl, error: tplErr } = await supabase
    .from('meal_plan_templates')
    .select('id, title, description, targets, week_structure')
    .eq('id', template_id)
    .single()
  if (tplErr) throw tplErr
  if (!tpl) throw new Error('Template not found')

  // 2) Insert snapshot into client_meal_plans
  const payload = {
    client_id,
    template_id: tpl.id,
    start_date: start_date || new Date().toISOString().slice(0, 10),
    title: tpl.title,
    targets: tpl.targets || {},
    week_structure: tpl.week_structure || []
  }

  const { data, error } = await supabase
    .from('client_meal_plans')
    .insert([payload])
    .select('*')
    .single()
  if (error) throw error
  return data
}

/** =========================
 *  SHARED HELPERS
 *  ========================= */
export async function fetchMealsByIds(ids = []) {
  const unique = [...new Set(ids)].filter(Boolean)
  if (!unique.length) return []
  const { data, error } = await supabase
    .from('meals')
    .select('*')
    .in('id', unique)
  if (error) throw error
  return data || []
}

/** =========================
 *  CLIENT OVERRIDES (optioneel; alleen gebruiken als je de SQL-tabellen hebt aangemaakt)
 *  Table: client_meal_plan_overrides(plan_id, client_id, day_index int, slot text, meal_id)
 *  ========================= */
export async function saveClientMealSwap({ plan_id, client_id, day_index, slot, meal_id }) {
  // Als de overrides-tabel niet bestaat of RLS blokkeert, gooit Supabase een error.
  const { data, error } = await supabase
    .from('client_meal_plan_overrides')
    .upsert(
      [{ plan_id, client_id, day_index, slot, meal_id }],
      { onConflict: 'plan_id,client_id,day_index,slot', ignoreDuplicates: false }
    )
    .select('*')
    .single()
  if (error) throw error
  return data
}

async function getOverrides(plan_id, client_id) {
  const { data, error } = await supabase
    .from('client_meal_plan_overrides')
    .select('day_index, slot, meal_id')
    .eq('plan_id', plan_id)
    .eq('client_id', client_id)
  if (error) throw error
  return data || []
}

export async function getClientPlanWithOverrides(client_id) {
  const plan = await getClientActiveMealPlan(client_id)
  if (!plan) return { plan: null, mergedWeekStructure: [] }

  // Basis = snapshot uit client_meal_plans
  const base = Array.isArray(plan.week_structure)
    ? JSON.parse(JSON.stringify(plan.week_structure))
    : []

  // Merge overrides als de tabel aanwezig is
  try {
    const overrides = await getOverrides(plan.id, client_id)
    for (const ov of overrides) {
      const d = base[ov.day_index]
      if (!d) continue
      if (!Array.isArray(d.meals)) d.meals = []
      const idx = d.meals.findIndex(m => m.slot === ov.slot)
      if (idx !== -1) d.meals[idx].meal_id = ov.meal_id ?? null
      else d.meals.push({ slot: ov.slot, meal_id: ov.meal_id ?? null })
    }
  } catch (e) {
    // Als overrides-tabel (nog) niet bestaat, negeren we dat stilletjes
    console.warn('Overrides not applied:', e?.message || e)
  }

  return { plan, mergedWeekStructure: base }
}

/** =========================
 *  SMART PLAN GENERATOR WITH PREFERENCE SCORING
 *  Intelligente meal planning met variatie, macro-balancing, portie-scaling en client preferences
 *  ========================= */

// Get pool of meals voor smart planner
export async function getPlannerMealsPool({ 
  allowedTags = [], 
  bannedTags = [], 
  kcalRange = { min: 0, max: 9999 },
  limit = 500 
} = {}) {
  let query = supabase
    .from('meals')
    .select('id, name, kcal, protein, carbs, fat, tags, category, default_portion')
    .gte('kcal', kcalRange.min)
    .lte('kcal', kcalRange.max)
    .limit(limit)

  if (allowedTags?.length) {
    query = query.contains('tags', allowedTags)
  }
  
  // Filter banned tags na ophalen (Supabase heeft geen NOT contains)
  const { data, error } = await query
  if (error) throw error
  
  let filtered = data || []
  if (bannedTags?.length) {
    filtered = filtered.filter(meal => 
      !meal.tags?.some(tag => bannedTags.includes(tag))
    )
  }
  
  return filtered
}

// **UPDATED: Smart plan generator met preference scoring**
export async function generateSmartPlanForClient({
  client_id,
  plan_id,
  start_date,
  preferences = {}, // NEW: Client preferences object with preferred_meal_ids array
  dailyKcalTarget = 2000,
  dailyMacroTargets = { protein: 150, carbs: 200, fat: 67 },
  mealsPerDay = 4,
  allergies = []
}) {
  try {
    console.log('ðŸš€ Generating smart plan with preferences:', preferences)
    
    // 1. Haal meals pool op
    const mealsPool = await getPlannerMealsPool({
      allowedTags: preferences.allowedTags || [],
      bannedTags: allergies,
      limit: 600
    })
    
    if (!mealsPool.length) {
      throw new Error('Geen meals gevonden met deze criteria')
    }

    // 2. Categoriseer meals
    const mealsByCategory = {
      breakfast: [],
      lunch: [],
      dinner: [],
      snack: []
    }
    
    mealsPool.forEach(meal => {
      // Detecteer category uit tags of naam als niet aanwezig
      let category = meal.category
      if (!category) {
        if (meal.tags?.includes('ontbijt') || meal.tags?.includes('breakfast') || 
            /overnight|oats|yoghurt|granola|muesli/i.test(meal.name)) {
          category = 'breakfast'
        } else if (meal.tags?.includes('lunch') || /salade|bowl|wrap|sandwich/i.test(meal.name)) {
          category = 'lunch'
        } else if (meal.tags?.includes('diner') || meal.tags?.includes('dinner') || 
                   /curry|pasta|rijst|stamppot/i.test(meal.name)) {
          category = 'dinner'
        } else {
          category = 'snack'
        }
      }
      
      if (mealsByCategory[category]) {
        mealsByCategory[category].push(meal)
      } else {
        mealsByCategory.snack.push(meal)
      }
    })

    console.log(`ðŸ“Š Meals available: ${mealsByCategory.breakfast.length} breakfast, ${mealsByCategory.lunch.length} lunch, ${mealsByCategory.dinner.length} dinner, ${mealsByCategory.snack.length} snacks`)

    // 3. Bereken target calories per meal slot
    const mealDistribution = {
      breakfast: 0.25,  // 25% van dagelijkse calorieÃ«n
      lunch: 0.30,      // 30%
      dinner: 0.35,     // 35%
      snack: 0.10       // 10% (kan meerdere snacks zijn)
    }
    
    // 4. Genereer 28 dagen
    const weekStructure = []
    const usedMealsTracker = new Map() // Track laatste gebruik per meal
    const MIN_DAYS_BETWEEN_REPEATS = 3
    let totalMealsPlanned = 0
    
    for (let day = 0; day < 28; day++) {
      const dayMeals = []
      const dayDate = new Date(start_date)
      dayDate.setDate(dayDate.getDate() + day)
      
      // Plan meals voor deze dag
      const mealSlots = mealsPerDay <= 3 ? 
        ['breakfast', 'lunch', 'dinner'] :
        mealsPerDay === 4 ?
        ['breakfast', 'lunch', 'dinner', 'snack'] :
        ['breakfast', 'snack', 'lunch', 'snack', 'dinner']
      
      mealSlots.forEach((slotCategory, slotIndex) => {
        const targetKcal = dailyKcalTarget * (mealDistribution[slotCategory] || 0.10)
        
        // Selecteer beste meal voor dit slot
        const candidates = mealsByCategory[slotCategory] || mealsByCategory.snack
        
        // **PREFERENCE SCORING** - Score candidates op basis van:
        // 1. CLIENT PREFERENCES (HUGE BONUS!)
        // 2. Calorie match
        // 3. Variatie (niet recent gebruikt)
        // 4. Macro fit
        const scoredCandidates = candidates.map(meal => {
          let score = 100
          
          // **PREFERENCE SCORING - Massive bonus voor client favorieten**
          if (preferences && preferences.preferred_meal_ids) {
            if (preferences.preferred_meal_ids.includes(meal.id)) {
              score += 500 // HUGE bonus voor preferred meals!
              console.log(`ðŸŽ¯ Preference bonus for: ${meal.name} (+500 points)`)
            }
          }
          
          // Calorie matching (belangrijkst na preferences)
          const calorieDiff = Math.abs(meal.kcal - targetKcal)
          score -= (calorieDiff / 10) // -1 punt per 10 kcal afwijking
          
          // Variatie bonus
          const lastUsed = usedMealsTracker.get(meal.id)
          if (lastUsed !== undefined) {
            const daysSinceUsed = day - lastUsed
            if (daysSinceUsed < MIN_DAYS_BETWEEN_REPEATS) {
              score -= (100 - daysSinceUsed * 20) // Zware penalty voor recent gebruik
            } else {
              score += Math.min(daysSinceUsed * 2, 50) // Bonus voor lang niet gebruikt
            }
          } else {
            score += 50 // Bonus voor nog nooit gebruikt
          }
          
          // Macro fit (indien binnen 20% van target)
          const proteinRatio = meal.protein / (dailyMacroTargets.protein / mealsPerDay)
          if (proteinRatio > 0.8 && proteinRatio < 1.2) {
            score += 10
          }
          
          // Protein preference for breakfast and post-workout
          if (slotCategory === 'breakfast' && meal.protein > 20) {
            score += 30
          }
          
          // Avoid too high calorie meals early in day
          if (slotIndex === 0 && meal.kcal > 500) {
            score -= 40
          }
          
          return { meal, score: Math.max(0, score) }
        })
        
        // Sorteer op score en kies beste optie
        scoredCandidates.sort((a, b) => b.score - a.score)
        const selected = scoredCandidates[0]?.meal
        
        if (selected) {
          dayMeals.push({
            slot: `${slotCategory}${slotIndex > 0 ? slotIndex : ''}`,
            meal_id: selected.id,
            portion: selected.default_portion || '1 portie',
            meal_type: slotCategory
          })
          
          // Update tracker
          usedMealsTracker.set(selected.id, day)
          totalMealsPlanned++
          
          console.log(`âœ… Day ${day + 1}, Meal ${slotIndex + 1}: ${selected.name} (${selected.kcal} kcal, score: ${scoredCandidates[0].score})`)
        }
      })
      
      weekStructure.push({
        day: `Day ${day + 1}`,
        date: dayDate.toISOString().slice(0, 10),
        meals: dayMeals
      })
    }

    // 5. Update plan in database (direct update naar week_structure)
    const { error } = await supabase
      .from('client_meal_plans')
      .update({ 
        week_structure: weekStructure,
        updated_at: new Date().toISOString()
      })
      .eq('id', plan_id)

    if (error) {
      console.error('Update error:', error)
      throw error
    }
    
    console.log(`ðŸŽ‰ Plan generated successfully! ${totalMealsPlanned} meals planned using ${usedMealsTracker.size} unique recipes`)
    
    // 6. Return de structure
    return { 
      weekStructure,
      diagnostics: {
        totalMealsPlanned,
        uniqueMealsUsed: usedMealsTracker.size,
        averageVarietyScore: Math.round((usedMealsTracker.size / mealsPool.length) * 100),
        mealsPerDay,
        preferenceHits: preferences?.preferred_meal_ids?.length || 0
      }
    }
    
  } catch (error) {
    console.error('Smart plan generation failed:', error)
    throw error
  }
}

// **UPDATED: Regenereer specifieke dag met preference scoring**
export async function regenerateDay({
  client_id,
  plan_id,
  day_index,
  currentStructure,
  dailyKcalTarget = 2000,
  mealsPerDay = 4
}) {
  try {
    console.log(`ðŸ”„ Regenerating day ${day_index + 1}`)
    
    // Get client preferences
    const { data: clientData } = await supabase
      .from('clients')
      .select('meal_preferences')
      .eq('id', client_id)
      .single()
    
    const preferences = clientData?.meal_preferences || {}
    
    // Gebruik dezelfde logica als generateSmartPlan maar voor 1 dag
    const mealsPool = await getPlannerMealsPool({ limit: 200 })
    
    // Bepal welke meals al in andere dagen gebruikt worden (voor variatie)
    const usedMealIds = new Set()
    currentStructure.forEach((day, idx) => {
      if (Math.abs(idx - day_index) <= 3) { // Check 3 dagen ervoor en erna
        day.meals?.forEach(m => {
          if (m.meal_id) usedMealIds.add(m.meal_id)
        })
      }
    })
    
    // Categoriseer meals
    const mealsByCategory = {
      breakfast: mealsPool.filter(m => m.category === 'breakfast'),
      lunch: mealsPool.filter(m => m.category === 'lunch'),
      dinner: mealsPool.filter(m => m.category === 'dinner'),
      snack: mealsPool.filter(m => m.category === 'snack')
    }
    
    // Genereer nieuwe dag meals met preference scoring
    const dayMeals = []
    const slots = ['breakfast', 'lunch', 'dinner', 'snack']
    
    for (let i = 0; i < Math.min(mealsPerDay, slots.length); i++) {
      const slotCategory = slots[i]
      const targetKcal = dailyKcalTarget / mealsPerDay
      const candidates = mealsByCategory[slotCategory] || mealsByCategory.snack
      
      // Score met preference bonus
      const scoredCandidates = candidates.map(meal => {
        let score = 100
        
        // **PREFERENCE SCORING**
        if (preferences.preferred_meal_ids?.includes(meal.id)) {
          score += 500
          console.log(`ðŸŽ¯ Preference bonus for: ${meal.name} (+500 points)`)
        }
        
        // Calorie match
        const calorieDiff = Math.abs(meal.kcal - targetKcal)
        score -= (calorieDiff / 10)
        
        // Variety bonus
        if (!usedMealIds.has(meal.id)) {
          score += 50
        }
        
        return { meal, score: Math.max(0, score) }
      })
      
      scoredCandidates.sort((a, b) => b.score - a.score)
      const bestMatch = scoredCandidates[0]
      
      if (bestMatch?.meal) {
        dayMeals.push({
          slot: slots[i],
          meal_id: bestMatch.meal.id,
          portion: bestMatch.meal.default_portion || '1 portie',
          meal_type: slotCategory
        })
      }
    }
    
    // Update plan structure
    const updatedStructure = [...currentStructure]
    updatedStructure[day_index] = {
      day: `Day ${day_index + 1}`,
      meals: dayMeals
    }
    
    // Save to database
    const { error } = await supabase
      .from('client_meal_plans')
      .update({ 
        week_structure: updatedStructure,
        updated_at: new Date().toISOString()
      })
      .eq('id', plan_id)
    
    if (error) throw error
    
    return {
      day: updatedStructure[day_index]
    }
    
  } catch (error) {
    console.error('Day regeneration failed:', error)
    throw error
  }
}

// Regenereer hele week met preferences
export async function regenerateWeek({
  client_id,
  plan_id,
  week_index,
  currentStructure,
  dailyKcalTarget = 2000,
  dailyMacroTargets = { protein: 150, carbs: 200, fat: 67 },
  mealsPerDay = 4
}) {
  try {
    console.log(`ðŸ”„ Regenerating week ${week_index + 1}`)
    
    const startDayIndex = week_index * 7
    const endDayIndex = startDayIndex + 7
    
    // Genereer 7 nieuwe dagen
    const newWeekDays = []
    
    for (let dayIndex = startDayIndex; dayIndex < endDayIndex; dayIndex++) {
      const result = await regenerateDay({
        client_id,
        plan_id,
        day_index: dayIndex,
        currentStructure,
        dailyKcalTarget,
        mealsPerDay
      })
      
      newWeekDays.push(result.day)
    }
    
    return { week: newWeekDays }
    
  } catch (error) {
    console.error('Week regeneration failed:', error)
    throw error
  }
}

// Coach: Get all clients with their meal plan status
export async function getClientsWithMealPlanStatus(coach_id) {
  try {
    // Haal alle clients van deze coach
    const { data: clients, error: clientError } = await supabase
      .from('clients')
      .select('id, first_name, last_name, email, status, goals')
      .eq('trainer_id', coach_id)
      .eq('status', 'active')
      .order('created_at', { ascending: false })
    
    if (clientError) throw clientError
    
    // Voor elke client, check of ze een meal plan hebben
    const clientsWithStatus = await Promise.all(
      clients.map(async (client) => {
        const plans = await getClientMealPlans(client.id)
        return {
          ...client,
          hasMealPlan: plans.length > 0,
          latestPlanDate: plans[0]?.created_at || null
        }
      })
    )
    
    return clientsWithStatus
    
  } catch (error) {
    console.error('Error getting clients with meal plan status:', error)
    throw error
  }
}
